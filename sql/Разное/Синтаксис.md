
## HAVING

Оператор `HAVING` в SQL используется для фильтрации результатов агрегатных функций после группировки данных с помощью оператора `GROUP BY`. Он позволяет применять условия к группам строк, сгруппированным по определенному столбцу или столбцам.

```SQL
SELECT column1, aggregate_function(column2)
FROM table_name
GROUP BY column1
HAVING condition;
```

- `column1`: Столбец, по которому происходит группировка.
- `aggregate_function(column2)`: Агрегатная функция, применяемая к столбцу `column2` в каждой группе.
- `table_name`: Имя таблицы, из которой извлекаются данные.
- `condition`: Условие, применяемое к результатам агрегации.

```SQL
SELECT CustomerID, COUNT(OrderID) AS TotalOrders
FROM Orders
GROUP BY CustomerID
HAVING COUNT(OrderID) > 2;
```

**Разница между HAVING и WHERE:**
- **WHERE** проверяет условие для каждой строки отдельно и не поддерживает агрегатные функции. Он выполняется перед `GROUP BY`.
- **HAVING** проверяет условие для групп строк и используется с агрегатными функциями. Он выполняется после `GROUP BY`

## DISTINCT

Оператор `DISTINCT` в SQL используется для удаления дубликатов из результирующего набора данных. Он применяется к столбцам в операторе `SELECT` и возвращает только уникальные значения, исключая повторяющиеся.

```SQL
SELECT DISTINCT column1, column2, ...
FROM table_name;
```

- `column1, column2, ...`: Список столбцов, для которых вы хотите получить уникальные значения.
- `table_name`: Имя таблицы, из которой извлекаются данные.

```SQL
SELECT DISTINCT ColorName
FROM Colors;
```

Оператор `DISTINCT` часто используется для получения уникальных значений в столбце или наборе столбцов, что может быть полезно при анализе данных или создании отчетов. Он также может быть использован в сочетании с агрегатными функциями для подсчета количества уникальных значений.

## EXISTS

Оператор `EXISTS` в SQL используется для проверки наличия хотя бы одной строки в подзапросе. Он возвращает значение `TRUE`, если подзапрос возвращает одну или несколько строк, и `FALSE`, если подзапрос не возвращает никаких строк.

```SQL
SELECT column_name(s)
FROM table_name
WHERE EXISTS (
  SELECT column_name
  FROM table_name
  WHERE condition
);
```

- Оператор `EXISTS` проверяет, возвращает ли подзапрос хотя бы одну строку. Если это так, он возвращает `TRUE`, иначе — `FALSE`.
- Он часто используется в условии `WHERE` для фильтрации строк основного запроса на основе данных из другой таблицы.
- `EXISTS` прекращает выполнение подзапроса сразу после нахождения первой подходящей строки, что делает его эффективным при работе с большими наборами данных.

```SQL
SELECT customer_id, first_name
FROM Customers
WHERE EXISTS (
  SELECT order_id
  FROM Orders
  WHERE Orders.customer_id = Customers.customer_id
);
```

Этот запрос вернет все строки из таблицы `Customers`, для которых существует хотя бы один заказ в таблице `Orders`. Другими словами, он выведет идентификатор и имя всех клиентов, которые совершили хотя бы один заказ.

**Различия с другими операторами:**
- **EXISTS vs. IN:** `EXISTS` более эффективен при работе с большими наборами данных, так как прекращает выполнение после нахождения первого соответствия, в то время как `IN` проверяет все значения.
- **EXISTS vs. JOIN:** `EXISTS` не создает дубликатов, в отличие от `JOIN`, который может потребовать дополнительного использования `DISTINCT` для удаления дубликатов

## WITH

Предложение `WITH` в SQL используется для создания временного именованного результирующего набора данных, называемого **обобщенным табличным выражением (ОТВ)**. ОТВ позволяет упростить сложные запросы, разбивая их на более простые и понятные части.

Предложение `WITH` определяет временную таблицу, которая существует только в течение выполнения запроса. Эта таблица может быть использована в операторах `SELECT`, `INSERT`, `UPDATE`, `DELETE` или `MERGE`.

```SQL
WITH имя_отв AS (
    SELECT ... FROM ...
)
SELECT ... FROM имя_отв;
```

Пример использования:

```SQL
WITH top_employees AS (
    SELECT employee_id, salary
    FROM employees
    ORDER BY salary DESC
    LIMIT 10
)
SELECT * FROM top_employees;
```

- **Рекурсивные ОТВ:** ОТВ может ссылаться на себя, что позволяет использовать рекурсивные запросы для обработки иерархических данных.
- **Упрощение запросов:** ОТВ помогает разбить сложные запросы на более простые и понятные части, что облегчает их поддержку и отладку.



## STRING_AGG

Функция `STRING_AGG` в SQL используется для агрегирования строковых значений в одну строку через указанный разделитель. В вашем запросе она объединяет идентификаторы (`id`) из двух таблиц (`Student` и `Hobby`) через запятую, сортируя результаты по идентификаторам.

```SQL
SELECT STRING_AGG(t1.id::VARCHAR, ',' ORDER BY t1.id) AS result
FROM (
    SELECT s.id FROM Student AS s
    UNION
    SELECT h.id FROM Hobby AS h
) AS t1;
```

Запрос вернет одну строку, содержащую все уникальные идентификаторы из таблиц `Student` и `Hobby`, перечисленные через запятую и отсортированные по возрастанию. Дубликаты удаляются при объединении таблиц.

## CASE

Конструкция `CASE` в SQL — это условный оператор, который позволяет выполнять различные действия в зависимости от условий. Он аналогичен логике `if-else` в языках программирования.

```PostgreSQL
CASE
    WHEN условие THEN результат
    WHEN условие THEN результат
    ELSE значение_по_умолчанию
END
```

- **Проверка условий:** Условия проверяются последовательно сверху вниз.
- **Остановка на первом удовлетворенном условии:** Как только условие удовлетворяется, возвращается соответствующее значение, и дальнейшая проверка останавливается.
- **ELSE:** Если ни одно условие не удовлетворяется, возвращается значение, указанное после `ELSE`. Если `ELSE` не указано, возвращается `NULL`.

```PostgreSQL
SELECT
    CASE
        WHEN salary >= 3000 THEN 'ЗП >= 3000'
        WHEN salary >= 2000 THEN '2000 <= ЗП < 3000'
        ELSE 'ЗП < 2000'
    END AS salary_type
FROM employees;
```

## CAST

Функция `CAST` в SQL — это функция преобразования типов данных, которая позволяет преобразовать значение из одного типа данных в другой. Она поддерживается в большинстве СУБД, включая SQL Server, Oracle, MySQL и PostgreSQL.

```PostgreSQL
CAST(expression AS type)
```

Пример №1:

```PostgreSQL
SELECT CAST(123 AS VARCHAR);
```

Пример №2

```PostgreSQL
SELECT CAST('2023-01-01' AS DATE);
```

Пример №3

```SQL
SELECT CAST(12.81 AS INT);  -- Результат: 12
```

## IN

Оператор `IN` в SQL — это условный оператор, который позволяет проверить, входит ли значение в определенный список значений или в набор значений, возвращаемый подзапросом. Он используется для фильтрации данных и упрощает запросы, заменяя несколько условий `OR`.

```SQL
SELECT column1, column2, ...
FROM table_name
WHERE column_name IN (SELECT column_name FROM another_table);
```

Оператор `IN` работает с колонкой, а не с кортежем, поэтому передавать в него нужно только список значений, собранных из одной колонки.

Пример №1:

```SQL
SELECT * FROM employees WHERE department IN ('Sales', 'Marketing');
```

Пример №2:

```SQL
SELECT * FROM orders WHERE customer_id IN (SELECT id FROM customers WHERE country='USA');
```

## NULLS LAST

Эта конструкция указывает, что значения NULL должны быть помещены в конец отсортированного списка. Это означает, что сначала будут отображаться все не-NULL значения, а затем — NULL.

Чтобы запрос работал корректно, необходимо указать столбец для сортировки. Например:

```SQL
SELECT reg_num
FROM Student
ORDER BY reg_num NULLS LAST
LIMIT 1;
```

## NULLS FIRST

Если бы использовалась эта конструкция, значения NULL были бы помещены в начало отсортированного списка.

## INTERVAL

`INTERVAL` — это команда в SQL, которая позволяет добавлять или вычитать определенные временные интервалы из даты или времени. Она используется для манипуляций с датами и временем в запросах.

```SQL
SELECT дата + INTERVAL что_прибавить FROM таблица;
SELECT дата - INTERVAL что_отнять FROM таблица;
```

Добавление дня:

```SQL
SELECT дата + INTERVAL 1 DAY AS new_date FROM таблица;
```

Добавление месяца:

```SQL
SELECT дата - INTERVAL 1 MONTH AS new_date FROM таблица;
```

Добавление года и месяца:

```SQL
SELECT дата + INTERVAL "1-2" YEAR_MONTH AS new_date FROM таблица;
```

## EXPLAIN

План запроса `EXPLAIN` — это команда SQL, которая позволяет анализировать план выполнения запроса, генерируемый системой управления базами данных (СУБД). Этот план показывает, как СУБД собирается выполнить запрос, включая порядок операций, использование индексов и оценку стоимости выполнения.

**Что показывает EXPLAIN:**

1. **Операции:** План выполнения включает различные операции, такие как сканирование таблиц, соединение таблиц, агрегирование данных и сортировка.
    
2. **Использование индексов:** Если в таблице есть индекс, который может быть использован для оптимизации запроса, `EXPLAIN` покажет, как этот индекс будет использован.
    
3. **Оценка стоимости:** Для каждой операции в плане указывается оценка стоимости, которая включает время запуска и общую стоимость выполнения.
    
4. **Порядок выполнения:** План выполнения представляет собой дерево узлов, где каждый узел соответствует определенной операции. Порядок выполнения операций определяется структурой дерева.

```SQL
EXPLAIN SELECT * FROM mytable WHERE id = 10;
```

Вывод команды `EXPLAIN` может выглядеть примерно так:

```SQL
QUERY PLAN
-------------------------------------------------------------
Index Scan using mytable_id_idx on mytable (cost=0.00..8.27 rows=1 width=4)
  Index Cond: (id = 10)
```

Этот пример показывает, что запрос будет выполнен с помощью индексного сканирования по индексу `mytable_id_idx`, что является эффективным способом найти строку с `id = 10`.

## OFFSET

`OFFSET` — это оператор SQL, который используется для пропуска определенного количества строк в начале набора данных, возвращаемого запросом. Он обычно используется в сочетании с оператором `LIMIT` для реализации постраничного отображения результатов.

```SQL
SELECT column1, column2, ...
FROM table_name
ORDER BY column_name
LIMIT number_of_rows OFFSET offset_value;
```

- `OFFSET` указывает, сколько строк нужно пропустить перед началом выборки результатов.
- `LIMIT` определяет количество строк, которые будут возвращены после пропуска указанного количества строк.

```SQL
SELECT ProductID, ProductName, Category
FROM Products
ORDER BY ProductName
LIMIT 3 OFFSET 3;
```

	Этот запрос отсортирует продукты по имени, пропустит первые 3 строки и затем вернет следующие 3 строки.
  