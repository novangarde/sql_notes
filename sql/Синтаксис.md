
## Оконные функции

Оконные функции в SQL — это мощный инструмент, который позволяет выполнять сложные вычисления над группами строк, связанных с текущей строкой. Они сохраняют исходные строки и добавляют к ним результаты вычислений, что отличает их от агрегатных функций, которые группируют строки в одну строку результата.

Оконные функции работают с набором строк, называемым "окном", и выполняют вычисления для каждой строки в этом окне. Они определяются с помощью предложения `OVER()`, которое позволяет задать порядок и партиционирование строк.

### Типы оконных функций

1. **Агрегатные функции:**
    - `SUM()`, `MAX()`, `MIN()`, `AVG()`, `COUNT()`.
    - Эти функции вычисляют агрегированные значения для набора строк, но в отличие от обычных агрегатных функций, они возвращают результат для каждой строки, а не сводят все строки в одну.

```SQL
SELECT sale_date, sales_amount,
       SUM(sales_amount) OVER (ORDER BY sale_date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS rolling_sum
FROM sales;
/*
ROWS BETWEEN 6 PRECEDING AND CURRENT ROW - строки между шестью предыдущими и текущей строкой
*/
```

2. **Ранжирующие функции:**
    - `ROW_NUMBER()`, `RANK()`, `DENSE_RANK()`.
    - Используются для присвоения рангов или номеров строкам на основе определенного порядка.
    - Если две или более строки имеют одинаковое значение, они получат одинаковый ранг, а следующая строка получит ранг, который на единицу больше, чем количество ранжированных строк с одинаковым значением.

```SQL
SELECT employee_id, salary,
       RANK() OVER (ORDER BY salary DESC) AS salary_rank
FROM employees;
```

3. **Функции смещения:**    
    - `LAG()`, `LEAD()`, `FIRST_VALUE()`, `LAST_VALUE()`.
    - Позволяют обращаться к значениям в предыдущих или последующих строках относительно текущей строки.

	**LAG():**
```SQL
SELECT employee_id, salary,
       LAG(salary) OVER (ORDER BY employee_id) AS previous_salary
FROM employees;
/*
Возвращает значение зарплаты из предыдущей строки. Если не указано смещение, по умолчанию используется смещение 1, то есть возвращает значение из строки, непосредственно предшествующей текущей.
*/
```

	**FIRST_VALUE(), LAST_VALUE():**
```SQL
SELECT employee_id, salary,
       FIRST_VALUE(salary) OVER (PARTITION BY employee_id ORDER BY date) AS first_salary,
       LAST_VALUE(salary) OVER (PARTITION BY employee_id ORDER BY date) AS last_salary
FROM salaries;
/*
FIRST_VALUE() и LAST_VALUE() нужны для получения первой и последней зарплаты каждого сотрудника на основе даты.
*/
```

4. **Аналитические функции:**
    - Используются для вычислений на основе движущегося окна строк, например, для расчета скользящих средних или кумулятивных сумм.

### ROW_NUMBER()

Функция `ROW_NUMBER()` в SQL используется для присвоения уникального номера каждой строке в результирующем наборе данных. Она часто применяется в аналитических запросах, где необходимо упорядочить строки и получить номер каждой строки в зависимости от заданного порядка.

```SQL
ROW_NUMBER() OVER (PARTITION BY column1, column2, ... ORDER BY column1 [ASC|DESC], column2 [ASC|DESC])
```

- **PARTITION BY** (необязательный): Делит результирующий набор на группы, для каждой из которых функция `ROW_NUMBER` будет вычислена независимо. Если не указано, все строки обрабатываются как одна группа.
- **ORDER BY** (обязательный): Определяет порядок, в котором строкам назначаются номера. Это определяет, как будет происходить нумерация строк.

```SQL
SELECT employee_id, salary, 
       ROW_NUMBER() OVER (ORDER BY salary DESC) AS RowNum
FROM Employees;
```

- **Уникальность номеров:** В отличие от функций `RANK` и `DENSE_RANK`, функция `ROW_NUMBER` всегда присваивает уникальный номер каждой строке, даже если значения в упорядочиваемом столбце совпадают. Например, если два сотрудника имеют одинаковую зарплату, один из них получит номер 1, а другой — 2.
- **Применение в пагинации:** Функция `ROW_NUMBER()` часто используется для реализации пагинации результатов. Например, чтобы получить определенную страницу результатов:

### OVER

Функция `ROW_NUMBER()` всегда используется в сочетании с предложением `OVER()`. Предложение `OVER()` определяет порядок и партиционирование строк, для которых функция `ROW_NUMBER()` присваивает уникальные номера. В `OVER()` можно указать `PARTITION BY` для группировки строк и `ORDER BY` для определения порядка нумерации.

Предложение `OVER` в SQL используется для определения окна или набора строк, для которых применяется оконная функция. Оно позволяет указать, как строки будут секционированы и упорядочены перед применением функции.

### PARTITION

Предложение `PARTITION BY` в SQL используется для разделения результирующего набора данных на группы или партиции на основе одного или нескольких столбцов. Это позволяет применять оконные функции к каждой группе отдельно, что особенно полезно для аналитических вычислений.

1. **Разделение на группы:**  
    `PARTITION BY` разделяет строки на подмножества на основе указанных столбцов. Все строки с одинаковыми значениями в этих столбцах будут относиться к одной группе.
2. **Применение оконных функций:**  
    Окнные функции, такие как `SUM`, `AVG`, `ROW_NUMBER`, `RANK`, применяются к каждой группе отдельно. Это позволяет выполнять вычисления внутри каждой партиции независимо от других.

```SQL
SELECT type, object_id,
       MIN(object_id) OVER (PARTITION BY type) AS min_id
FROM sys.objects;
```

## HAVING

Оператор `HAVING` в SQL используется для фильтрации результатов агрегатных функций после группировки данных с помощью оператора `GROUP BY`. Он позволяет применять условия к группам строк, сгруппированным по определенному столбцу или столбцам.

```SQL
SELECT column1, aggregate_function(column2)
FROM table_name
GROUP BY column1
HAVING condition;
```

- `column1`: Столбец, по которому происходит группировка.
- `aggregate_function(column2)`: Агрегатная функция, применяемая к столбцу `column2` в каждой группе.
- `table_name`: Имя таблицы, из которой извлекаются данные.
- `condition`: Условие, применяемое к результатам агрегации.

```SQL
SELECT CustomerID, COUNT(OrderID) AS TotalOrders
FROM Orders
GROUP BY CustomerID
HAVING COUNT(OrderID) > 2;
```

**Разница между HAVING и WHERE:**
- **WHERE** проверяет условие для каждой строки отдельно и не поддерживает агрегатные функции. Он выполняется перед `GROUP BY`.
- **HAVING** проверяет условие для групп строк и используется с агрегатными функциями. Он выполняется после `GROUP BY`

## DISTINCT

Оператор `DISTINCT` в SQL используется для удаления дубликатов из результирующего набора данных. Он применяется к столбцам в операторе `SELECT` и возвращает только уникальные значения, исключая повторяющиеся.

```SQL
SELECT DISTINCT column1, column2, ...
FROM table_name;
```

- `column1, column2, ...`: Список столбцов, для которых вы хотите получить уникальные значения.
- `table_name`: Имя таблицы, из которой извлекаются данные.

```SQL
SELECT DISTINCT ColorName
FROM Colors;
```

Оператор `DISTINCT` часто используется для получения уникальных значений в столбце или наборе столбцов, что может быть полезно при анализе данных или создании отчетов. Он также может быть использован в сочетании с агрегатными функциями для подсчета количества уникальных значений.

## EXISTS

Оператор `EXISTS` в SQL используется для проверки наличия хотя бы одной строки в подзапросе. Он возвращает значение `TRUE`, если подзапрос возвращает одну или несколько строк, и `FALSE`, если подзапрос не возвращает никаких строк.

```SQL
SELECT column_name(s)
FROM table_name
WHERE EXISTS (
  SELECT column_name
  FROM table_name
  WHERE condition
);
```

- Оператор `EXISTS` проверяет, возвращает ли подзапрос хотя бы одну строку. Если это так, он возвращает `TRUE`, иначе — `FALSE`.
- Он часто используется в условии `WHERE` для фильтрации строк основного запроса на основе данных из другой таблицы.
- `EXISTS` прекращает выполнение подзапроса сразу после нахождения первой подходящей строки, что делает его эффективным при работе с большими наборами данных.

```SQL
SELECT customer_id, first_name
FROM Customers
WHERE EXISTS (
  SELECT order_id
  FROM Orders
  WHERE Orders.customer_id = Customers.customer_id
);
```

Этот запрос вернет все строки из таблицы `Customers`, для которых существует хотя бы один заказ в таблице `Orders`. Другими словами, он выведет идентификатор и имя всех клиентов, которые совершили хотя бы один заказ.

**Различия с другими операторами:**
- **EXISTS vs. IN:** `EXISTS` более эффективен при работе с большими наборами данных, так как прекращает выполнение после нахождения первого соответствия, в то время как `IN` проверяет все значения.
- **EXISTS vs. JOIN:** `EXISTS` не создает дубликатов, в отличие от `JOIN`, который может потребовать дополнительного использования `DISTINCT` для удаления дубликатов

## WITH

Предложение `WITH` в SQL используется для создания временного именованного результирующего набора данных, называемого **обобщенным табличным выражением (ОТВ)**. ОТВ позволяет упростить сложные запросы, разбивая их на более простые и понятные части.

Предложение `WITH` определяет временную таблицу, которая существует только в течение выполнения запроса. Эта таблица может быть использована в операторах `SELECT`, `INSERT`, `UPDATE`, `DELETE` или `MERGE`.

```SQL
WITH имя_отв AS (
    SELECT ... FROM ...
)
SELECT ... FROM имя_отв;
```

Пример использования:

```SQL
WITH top_employees AS (
    SELECT employee_id, salary
    FROM employees
    ORDER BY salary DESC
    LIMIT 10
)
SELECT * FROM top_employees;
```

- **Рекурсивные ОТВ:** ОТВ может ссылаться на себя, что позволяет использовать рекурсивные запросы для обработки иерархических данных.
- **Упрощение запросов:** ОТВ помогает разбить сложные запросы на более простые и понятные части, что облегчает их поддержку и отладку.

## JOIN

Оператор `JOIN` в SQL — это мощный инструмент, который позволяет объединять данные из нескольких таблиц в одну таблицу на основе определенных условий. Это особенно полезно в реляционных базах данных, где информация часто распределена по разным таблицам.

1. **Объединение таблиц:** JOIN объединяет строки из двух или более таблиц на основе заданного условия, обычно по общему столбцу (ключу).
2. **Условие соединения:** Условие соединения определяет, какие строки из одной таблицы будут объединены со строками из другой таблицы.
3. **Результат:** Результатом является новая таблица, содержащая столбцы из обеих исходных таблиц.

### INNER JOIN

- Возвращает только строки, которые имеют совпадения в обеих таблицах.
- Используется для получения данных, которые присутствуют в обеих таблицах.

```SQL
SELECT employees.name, departments.department_name
FROM employees
INNER JOIN departments ON employees.department_id = departments.department_id;
```

### LEFT JOIN

- Возвращает все строки из левой таблицы и совпадающие (подходящие под условие) строки из правой таблицы.
- Если в правой таблице нет совпадений (по условию из `ON`), возвращаются `NULL` для правой таблицы.

```SQL
SELECT employees.name, departments.department_name
FROM employees
LEFT JOIN departments ON employees.department_id = departments.department_id;
```

### RIGHT JOIN

- Аналогичен LEFT JOIN, но возвращает все строки из правой таблицы и совпадающие из левой.

```SQL
SELECT employees.name, departments.department_name
FROM employees
RIGHT JOIN departments ON employees.department_id = departments.department_id;
```

### FULL JOIN

- Возвращает все строки из обеих таблиц, независимо от наличия совпадений.
- Если нет совпадений, возвращаются `NULL` для другой таблицы.

```SQL
SELECT employees.name, departments.department_name
FROM employees
FULL JOIN departments ON employees.department_id = departments.department_id;
```

### CROSS JOIN

- Возвращает декартово произведение двух таблиц, то есть каждая строка левой таблицы объединяется с каждой строкой правой таблицы. К примеру, слева у нас столбцы 1, 2, 3, 4 и 5, а справа – 1, 2, 3, значит, вернется: 1-1, 1-2, 1-3, 2-1, 2-2, 2-3, ... 5-1, 5-2, 5-3.
- Не требует условия соединения.

```SQL
SELECT employees.name, departments.department_name
FROM employees
CROSS JOIN departments;
```

### SELF JOIN

- Используется для соединения таблицы с самой собой.
- Полезен для анализа иерархических данных или сравнения строк внутри одной таблицы.

```SQL
SELECT e1.name AS manager, e2.name AS employee
FROM employees e1
JOIN employees e2 ON e1.employee_id = e2.manager_id;
```

### OUTER

Не обязательный оператор, по сути, мы получаем тот же результат, что и без него.

Оператор `OUTER JOIN` в SQL — это тип соединения, который позволяет объединять данные из двух таблиц, включая все строки из одной или обеих таблиц, даже если нет совпадений по условию соединения. OUTER JOIN включает в себя три основных типа:

#### LEFT OUTER JOIN

- Возвращает все строки из левой таблицы и соответствующие строки из правой таблицы.
- Если в правой таблице нет совпадений, столбцы правой таблицы заполняются `NULL`.

#### RIGHT OUTER JOIN

- Аналогичен LEFT JOIN, но возвращает все строки из правой таблицы и соответствующие строки из левой.
- Если в левой таблице нет совпадений, столбцы левой таблицы заполняются `NULL`.

#### FULL OUTER JOIN

- Объединяет все строки из обеих таблиц, включая строки без совпадений.
- Для строк без совпадений столбцы другой таблицы заполняются `NULL`.

OUTER JOIN используется для получения полного набора данных из обеих таблиц, что особенно полезно при анализе данных, когда необходимо учитывать все возможные варианты, даже если нет совпадений по условию соединения.

```SQL
SELECT a.id, b.value
FROM TableA a
LEFT JOIN TableB b ON a.key = b.key;
```

## UNION

Оператор `UNION` в SQL используется для объединения результатов двух или более запросов `SELECT` в один результирующий набор. Он исключает дубликаты строк, если они присутствуют в обоих наборах данных.

```SQL
SELECT column1, column2 FROM table1
UNION
SELECT column1, column2 FROM table2;
```

- Количество столбцов в обоих запросах должно быть одинаковым.
- Типы данных столбцов должны быть совместимыми.
- Столбцы должны быть в том же порядке в обоих запросах.

## UNION ALL

То же самое, что UNION, но не исключает дубликаты.

## STRING_AGG

Функция `STRING_AGG` в SQL используется для агрегирования строковых значений в одну строку через указанный разделитель. В вашем запросе она объединяет идентификаторы (`id`) из двух таблиц (`Student` и `Hobby`) через запятую, сортируя результаты по идентификаторам.

```SQL
SELECT STRING_AGG(t1.id::VARCHAR, ',' ORDER BY t1.id) AS result
FROM (
    SELECT s.id FROM Student AS s
    UNION
    SELECT h.id FROM Hobby AS h
) AS t1;
```

Запрос вернет одну строку, содержащую все уникальные идентификаторы из таблиц `Student` и `Hobby`, перечисленные через запятую и отсортированные по возрастанию. Дубликаты удаляются при объединении таблиц.

## CASE

Конструкция `CASE` в SQL — это условный оператор, который позволяет выполнять различные действия в зависимости от условий. Он аналогичен логике `if-else` в языках программирования.

```PostgreSQL
CASE
    WHEN условие THEN результат
    WHEN условие THEN результат
    ELSE значение_по_умолчанию
END
```

- **Проверка условий:** Условия проверяются последовательно сверху вниз.
- **Остановка на первом удовлетворенном условии:** Как только условие удовлетворяется, возвращается соответствующее значение, и дальнейшая проверка останавливается.
- **ELSE:** Если ни одно условие не удовлетворяется, возвращается значение, указанное после `ELSE`. Если `ELSE` не указано, возвращается `NULL`.

```PostgreSQL
SELECT
    CASE
        WHEN salary >= 3000 THEN 'ЗП >= 3000'
        WHEN salary >= 2000 THEN '2000 <= ЗП < 3000'
        ELSE 'ЗП < 2000'
    END AS salary_type
FROM employees;
```

## CAST

Функция `CAST` в SQL — это функция преобразования типов данных, которая позволяет преобразовать значение из одного типа данных в другой. Она поддерживается в большинстве СУБД, включая SQL Server, Oracle, MySQL и PostgreSQL.

```PostgreSQL
CAST(expression AS type)
```

Пример №1:

```PostgreSQL
SELECT CAST(123 AS VARCHAR);
```

Пример №2

```PostgreSQL
SELECT CAST('2023-01-01' AS DATE);
```

Пример №3

```SQL
SELECT CAST(12.81 AS INT);  -- Результат: 12
```

## IN

Оператор `IN` в SQL — это условный оператор, который позволяет проверить, входит ли значение в определенный список значений или в набор значений, возвращаемый подзапросом. Он используется для фильтрации данных и упрощает запросы, заменяя несколько условий `OR`.

```SQL
SELECT column1, column2, ...
FROM table_name
WHERE column_name IN (SELECT column_name FROM another_table);
```

Оператор `IN` работает с колонкой, а не с кортежем, поэтому передавать в него нужно только список значений, собранных из одной колонки.

Пример №1:

```SQL
SELECT * FROM employees WHERE department IN ('Sales', 'Marketing');
```

Пример №2:

```SQL
SELECT * FROM orders WHERE customer_id IN (SELECT id FROM customers WHERE country='USA');
```

## NULLS LAST

Эта конструкция указывает, что значения NULL должны быть помещены в конец отсортированного списка. Это означает, что сначала будут отображаться все не-NULL значения, а затем — NULL.

Чтобы запрос работал корректно, необходимо указать столбец для сортировки. Например:

```SQL
SELECT reg_num
FROM Student
ORDER BY reg_num NULLS LAST
LIMIT 1;
```

## NULLS FIRST

Если бы использовалась эта конструкция, значения NULL были бы помещены в начало отсортированного списка.
